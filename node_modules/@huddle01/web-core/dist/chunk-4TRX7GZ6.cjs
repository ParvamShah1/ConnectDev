"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkQZEG6K3Mcjs = require('./chunk-QZEG6K3M.cjs');



var _chunkY4HA25UMcjs = require('./chunk-Y4HA25UM.cjs');



var _chunkXHHWH5ENcjs = require('./chunk-XHHWH5EN.cjs');


var _chunkCRVOHRUMcjs = require('./chunk-CRVOHRUM.cjs');


var _chunkB7RAAO3Dcjs = require('./chunk-B7RAAO3D.cjs');



var _chunk7RPWAXHIcjs = require('./chunk-7RPWAXHI.cjs');


var _chunkAA6KQKWQcjs = require('./chunk-AA6KQKWQ.cjs');


var _chunkO5HDCTOEcjs = require('./chunk-O5HDCTOE.cjs');

// src/Transport.ts
var logger = _chunkO5HDCTOEcjs.mainLogger.createSubLogger("Transport");
var Transport = (_class = class _Transport extends _chunkAA6KQKWQcjs.EnhancedEventEmitter {
  /**
   * Peer Id, which handles the peer id.
   */
  
  /**
   *  MediaSoup Device Instance, which handles the browsers or mobile device init.
   */
  
  /**
   * MediaSoup Transport Instance, which handles the media transport.
   */
  
  /**
   * Socket Instance, which handles the socket connection.
   */
  
  /**
   * Map of Producers, which handles the producers. ( Sending out Media Streams )
   *
   * `Mapped with {producerId => Producer}`
   */
  __init() {this.__producers = /* @__PURE__ */ new Map()}
  /**
   * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
   *
   * `Mapped with {label => DataProducer}`
   */
  __init2() {this.__dataProducers = /* @__PURE__ */ new Map()}
  /**
   * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
   *
   * `Mapped with {label:label => DataConsumer}`
   */
  __init3() {this.__dataConsumers = /* @__PURE__ */ new Map()}
  /**
   * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
   *
   * `Mapped with {label:RemotePeerId => Consumer}`
   */
  __init4() {this.__consumers = new (0, _chunkQZEG6K3Mcjs.EnhancedMap)({})}
  /**
   * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
   *
   * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
   */
  __init5() {this.labelToProducerId = /* @__PURE__ */ new Map()}
  /**
   * Transport Type, which handles the transport type. ( `send | recv` )
   */
  
  /**
   * Pending Producer Tasks, which handles the pending producer tasks.
   * callback function is necessary to be called when the producer is created
   * on the server as well as on the client side.
   */
  __init6() {this.__pendingProducerTasks = /* @__PURE__ */ new Map()}
  /**
   * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
   * more requests to restart ice.
   */
  __init7() {this.__iceRestartDebounce = false}
  get device() {
    return this.__device;
  }
  get mediasoupTransport() {
    return this.__mediasoupTransport;
  }
  get connectionState() {
    return this.__mediasoupTransport.connectionState;
  }
  get producers() {
    return this.__producers;
  }
  get dataProducers() {
    return this.__dataProducers;
  }
  get dataConsumers() {
    return this.__dataConsumers;
  }
  get consumers() {
    return this.__consumers;
  }
  getProducerById(producerId) {
    const producer = this.__producers.get(producerId);
    if (!producer)
      throw new Error("Producer not found");
    return producer;
  }
  removeProducerById(producerId) {
    logger.info(`\u{1F514} Removing Producer, id: ${producerId}`);
    return this.__producers.delete(producerId);
  }
  /**
   * Get the consumer by label and peerId
   * @param data
   * @returns Consumer | null; Returns null if consumer is not found
   */
  __init8() {this.getConsumer = (data) => {
    const consumer = this.__consumers.get(data.label, data.peerId);
    if (!consumer)
      return null;
    return consumer;
  }}
  get transport() {
    const transport = this.__mediasoupTransport;
    if (!transport)
      throw new Error("Transport Not Initialized");
    return transport;
  }
  __init9() {this.addPendingProducerTask = (data) => {
    const key = `${data.peerId}-${_optionalChain([data, 'optionalAccess', _6 => _6.label])}`;
    logger.info("\u{1F514} Adding Pending Producer Task, key", key);
    if (this.__pendingProducerTasks.has(key)) {
      logger.debug("\u{1F534} Producer Creation is Pending for key: ", key);
      return;
    }
    this.__pendingProducerTasks.set(key, data.callback);
  }}
  __init10() {this.resolvePendingProducerTask = (data) => {
    const key = `${data.peerId}-${data.label}`;
    logger.info("\u{1F514} Resolving Pending Producer Task, key", key);
    const callback = this.__pendingProducerTasks.get(key);
    if (!callback) {
      logger.error("\u{1F534} Producer Creation is not Pending for key: ", key);
      return;
    }
    callback({ id: data.id });
    this.__pendingProducerTasks.delete(key);
  }}
  static __initStatic() {this.create = (data) => {
    try {
      logger.info(
        `\u{1F514} Creating Client Side Transport, type: ${data.transportType}`
      );
      const { transportType, device } = data;
      const payload = {
        id: data.sdpInfo.id,
        iceParameters: data.sdpInfo.iceParameters,
        iceCandidates: data.sdpInfo.iceCandidates,
        iceServers: data.iceServers,
        dtlsParameters: data.sdpInfo.dtlsParameters,
        sctpParameters: data.sdpInfo.sctpParameters,
        proprietaryConstraints: {},
        appData: {}
      };
      const mediasoupTransport = transportType === "send" ? device.createSendTransport(payload) : device.createRecvTransport(payload);
      const transport = new _Transport({
        peerId: data.peerId,
        device: data.device,
        transportType: data.transportType,
        mediasoupTransport
      });
      return transport;
    } catch (error) {
      logger.error(`\u274C Transport.create(), type: ${data.transportType}`);
      logger.error(error);
      throw error;
    }
  }}
  constructor(data) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);_class.prototype.__init6.call(this);_class.prototype.__init7.call(this);_class.prototype.__init8.call(this);_class.prototype.__init9.call(this);_class.prototype.__init10.call(this);_class.prototype.__init11.call(this);_class.prototype.__init12.call(this);_class.prototype.__init13.call(this);_class.prototype.__init14.call(this);_class.prototype.__init15.call(this);_class.prototype.__init16.call(this);_class.prototype.__init17.call(this);_class.prototype.__init18.call(this);_class.prototype.__init19.call(this);_class.prototype.__init20.call(this);;
    this.__socket = _chunkCRVOHRUMcjs.Socket_default.getInstance();
    this.__device = data.device;
    this.transportType = data.transportType;
    this.__mediasoupTransport = data.mediasoupTransport;
    this.__mediasoupTransport.on("connectionstatechange", (state) => {
      this.__connectionStateChangeHandler(state);
    });
    this.peerId = data.peerId;
    this.__listenTransportConnect();
    this.__listenTransportProduce();
    if (this.transportType === "send")
      this.__listenTransportDataProduce();
    logger.info(`\u2705 ${data.transportType} Transport Initialized`);
  }
  __init11() {this.__listenTransportConnect = () => {
    this.__mediasoupTransport.on(
      "connect",
      ({ dtlsParameters }, callback, errback) => {
        logger.info("\u{1F514} Transport Connect Event Called");
        try {
          this.once("connectTransportResponse", () => {
            callback();
          });
          this.__socket.publish("connectTransport", {
            dtlsParameters,
            transportType: this.transportType
          });
        } catch (error) {
          logger.error("\u274C Error Transport Connect Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  }}
  __init12() {this.__listenTransportProduce = () => {
    this.__mediasoupTransport.on(
      "produce",
      async ({ kind, rtpParameters, appData }, callback, errback) => {
        logger.info(`\u{1F514} ${this.transportType} Produce Event Called`);
        try {
          const label = _optionalChain([appData, 'optionalAccess', _7 => _7.label]);
          if (!label)
            throw new Error("\u{1F534} Stream Identifier Not Found");
          const parsedProtoRtpParameters = _chunkY4HA25UMcjs.parseToProtoRtpParameters.call(void 0, rtpParameters);
          this.__socket.publish("produce", {
            rtpParameters: parsedProtoRtpParameters,
            kind,
            label,
            appData,
            paused: false
          });
          this.addPendingProducerTask({
            peerId: this.peerId,
            label,
            callback
          });
        } catch (error) {
          logger.error("\u274C Error Transport Produce Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  }}
  __init13() {this.__listenTransportDataProduce = () => {
    logger.info(`\u{1F514} producedata: ${this.transportType} `);
    this.__mediasoupTransport.on(
      "producedata",
      async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {
        logger.info(`\u{1F514} ${this.transportType} Produce Data Event Called`);
        try {
          this.__socket.publish("produceData", {
            transportId: this.__mediasoupTransport.id,
            sctpStreamParameters,
            label,
            protocol,
            appData
          });
          this.addPendingProducerTask({
            peerId: this.peerId,
            label,
            callback
          });
        } catch (error) {
          logger.error("\u274C Error Transport Produce Data Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  }}
  __init14() {this.produce = async (data) => {
    const kind = _chunkXHHWH5ENcjs.getMediaStreamKind.call(void 0, data.stream);
    const track = _chunkXHHWH5ENcjs.getMediaTrack.call(void 0, { stream: data.stream, kind });
    logger.info(`\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);
    try {
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      if (!this.__device.canProduce(kind)) {
        throw new Error(`Device Cannot produce ${kind}`);
      }
      if (this.transportType !== "send") {
        throw new Error(`Cannot produce on ${this.transportType} transport`);
      }
      const codecs = _optionalChain([this, 'access', _8 => _8.__device, 'access', _9 => _9.rtpCapabilities, 'optionalAccess', _10 => _10.codecs]);
      if (!codecs) {
        throw new Error("\u274C Device RTP Capabilities not found");
      }
      const codecViaMediaType = {
        video: codecs.find(
          (codec) => codec.mimeType.toLowerCase() === "video/h264"
        ),
        "screen-share-video": codecs.find(
          (codec) => codec.mimeType.toLowerCase() === "video/h264"
        ),
        audio: void 0
      };
      const mediaType = data.label === "screen-share-video" ? "screen-share-video" : kind;
      const mediasoupProducer = await this.__mediasoupTransport.produce({
        track,
        encodings: _chunk7RPWAXHIcjs.encodingViaMediaType[mediaType],
        codecOptions: _chunk7RPWAXHIcjs.codecOptionsViaKind[kind],
        codec: codecViaMediaType[mediaType],
        stopTracks: data.stopTrackOnClose,
        zeroRtpOnPause: true,
        disableTrackOnPause: true,
        appData: {
          ...data.appData,
          producerPeerId: this.peerId
        }
      });
      this.__producers.set(mediasoupProducer.id, mediasoupProducer);
      this.labelToProducerId.set(data.label, mediasoupProducer.id);
      logger.info(`\u{1F514} Producer Created sucessfully with label : ${data.label}`);
      return mediasoupProducer;
    } catch (error) {
      logger.error("\u274C Error Transport Produce Event");
      logger.error(error);
      throw error;
    }
  }}
  __init15() {this.produceData = async (data) => {
    logger.info(`\u{1F514} Produce Data Called for label: ${data.label}`);
    try {
      if (this.transportType !== "send") {
        throw new Error(`Cannot produce on ${this.transportType} transport`);
      }
      const dataProducer = await this.__mediasoupTransport.produceData({
        label: data.label,
        appData: {
          ordered: true,
          ...data.appData,
          producerPeerId: this.peerId,
          label: data.label
        }
      });
      this.__dataProducers.set(dataProducer.label, dataProducer);
      return dataProducer;
    } catch (error) {
      logger.error("\u274C Error Transport Produce Data Event");
      logger.error(error);
      throw error;
    }
  }}
  __init16() {this.consume = async (data) => {
    const { label, producerPeerId, kind } = data;
    logger.info(
      `\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`
    );
    try {
      if (this.transportType !== "recv") {
        throw new Error(`Cannot consume on ${this.transportType} transport`);
      }
      const consumer = _chunkB7RAAO3Dcjs.Consumer_default.create({
        producerId: data.producerId,
        producerPeerId,
        label
      });
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      const parsedRtpParameters = _chunkY4HA25UMcjs.parseRtpParameters.call(void 0, data.rtpParameters);
      const mediaSoupConsumer = await this.__mediasoupTransport.consume({
        id: data.consumerId,
        rtpParameters: parsedRtpParameters,
        kind: data.kind,
        producerId: data.producerId,
        appData: data.appData
      });
      mediaSoupConsumer.on("transportclose", () => {
        this.closeConsumer({ label, peerId: producerPeerId });
      });
      mediaSoupConsumer.on("trackended", () => {
        this.closeConsumer({ label, peerId: producerPeerId });
      });
      this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);
      consumer.setMediaSoupConsumer(mediaSoupConsumer);
      return { consumer, mediaSoupConsumer };
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error calling consume()");
    }
  }}
  __init17() {this.consumeData = async (data) => {
    const {
      label,
      appData,
      dataProducerId,
      protocol,
      id,
      peerId,
      sctpStreamParameters
    } = data;
    logger.info(
      `\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`
    );
    try {
      if (this.transportType !== "recv") {
        throw new Error(`Cannot consume on ${this.transportType} transport`);
      }
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      const dataConsumer = await this.transport.consumeData({
        id,
        dataProducerId,
        sctpStreamParameters: {
          ...sctpStreamParameters,
          maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime === 0 ? void 0 : sctpStreamParameters.maxPacketLifeTime,
          maxRetransmits: sctpStreamParameters.maxRetransmits === 0 ? void 0 : sctpStreamParameters.maxRetransmits
        },
        label,
        protocol,
        appData
      });
      dataConsumer.on("open", () => {
        logger.info(`\u2705 DataConsumer with ${label} opened`);
      });
      dataConsumer.on("close", () => {
        logger.warn(`\u2705 DataConsumer with ${label} closed`);
        this.__dataConsumers.delete(label);
      });
      dataConsumer.on("error", (error) => {
        logger.error(`\u2705 DataConsumer "error": ${error} closed`);
      });
      this.__dataConsumers.set(label, dataConsumer);
      return dataConsumer;
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error calling consumeData()");
    }
  }}
  __init18() {this.closeConsumer = (data) => {
    try {
      const consumer = this.getConsumer(data);
      if (!consumer) {
        throw new Error(
          `\u274C Consumer not found label: ${data.label}, peerId: ${data.peerId}`
        );
      }
      consumer.close();
      this.__consumers.delete(data.label, data.peerId);
    } catch (error) {
      logger.error("\u274C Error closing consumer");
      logger.error(error);
    }
  }}
  __init19() {this.close = async (data) => {
    try {
      if (data.retries <= 0) {
        logger.error("\u274C Error closing transport, max retries exceeded");
        return;
      }
      logger.info(`\u{1F514} Closing ${this.transportType} transport`);
      this.__mediasoupTransport.close();
      logger.info(`\u2705 ${this.transportType} transport closed`);
    } catch (error) {
      logger.error("\u274C Error closing transport");
      logger.error(error);
      logger.error("Retrying...");
      this.close({ retries: data.retries - 1 });
    }
  }}
  __init20() {this.__connectionStateChangeHandler = (state) => {
    try {
      logger.debug(
        `\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`
      );
      const transportType = this.transportType;
      const handler = {
        connected: () => {
          logger.debug(`\u{1F514} ${this.transportType} Transport Connected`);
        },
        disconnected: () => {
          if (this.__iceRestartDebounce)
            return;
          this.__iceRestartDebounce = true;
          this.__socket.publish("restartTransportIce", {
            transportId: this.__mediasoupTransport.id,
            transportType
          });
          setTimeout(() => {
            this.__iceRestartDebounce = false;
          }, 3e3);
          logger.debug(`\u{1F514} ${transportType} Transport Disconnected`);
        },
        failed: () => {
          logger.debug(`\u{1F514} ${transportType} Transport Failed`);
        },
        connecting: () => {
          logger.debug(`\u{1F514} ${transportType} Transport Connecting`);
        },
        closed: () => {
          logger.debug(`\u{1F514} ${transportType} Transport closed`);
        },
        new: () => {
          logger.debug(`\u{1F514} ${transportType} Transport new`);
        }
      };
      handler[state]();
    } catch (err) {
      logger.error("\u274C Error in connectionStateChangeHandler");
      logger.error(err);
    }
  }}
}, _class.__initStatic(), _class);
var Transport_default = Transport;



exports.Transport_default = Transport_default;
