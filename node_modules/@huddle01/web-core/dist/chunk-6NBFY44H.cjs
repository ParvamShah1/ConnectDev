"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkVLUFOOD3cjs = require('./chunk-VLUFOOD3.cjs');


var _chunkAA6KQKWQcjs = require('./chunk-AA6KQKWQ.cjs');


var _chunkO5HDCTOEcjs = require('./chunk-O5HDCTOE.cjs');

// src/ActiveSpeakers.ts
var logger = _chunkO5HDCTOEcjs.mainLogger.createSubLogger("ActiveSpeakers");
var ActiveSpeakers = (_class = class _ActiveSpeakers extends _chunkAA6KQKWQcjs.EnhancedEventEmitter {
  /**
   * Instance of the ActiveSpeakers Class; used for singleton pattern.
   */
  
  /**
   * Get the instance of the ActiveSpeakers Class.
   * @returns ActiveSpeakers instance.
   */
  static getInstance() {
    if (!_ActiveSpeakers.__instance) {
      throw new Error("ActiveSpeakers not initialized");
    }
    return _ActiveSpeakers.__instance;
  }
  /**
   * Create the instance of the ActiveSpeakers Class.
   * @returns ActiveSpeakers instance.
   */
  static createInstance(data) {
    if (_ActiveSpeakers.__instance) {
      return _ActiveSpeakers.__instance;
    }
    _ActiveSpeakers.__instance = new _ActiveSpeakers(data);
    return _ActiveSpeakers.__instance;
  }
  /**
   * Room instance.
   */
  __init() {this.__room = _chunkVLUFOOD3cjs.Room_default.getInstance()}
  /**
   * Bot instance which has the data producer connected directly to the room bot.
   * This is used to handle all the states of the room and its functionality.
   */
  
  /**
   * Is the notification active.
   */
  
  /**
   * Is the notification active.
   */
  get active() {
    return this.__active;
  }
  /**
   * Maximum number of entries in the list.
   */
  __init2() {this.MAX_SIZE = 20}
  /**
   * Size by which the active speakers list will be notified.
   * `note: default size is 8`
   */
  
  /**
   * Size by which the active speakers list will be notified.
   */
  get size() {
    return this.__size;
  }
  /**
   * Array of ActiveSpeakers ordered by volume.
   */
  __init3() {this.__activePeerIds = []}
  /**
   * Update the number of peerIds to notify.
   * @param size
   */
  __init4() {this.updateSize = (size) => {
    logger.info("\u{1F514} Updating Active Speaker Size to", size);
    if (size > this.MAX_SIZE) {
      logger.error(
        "\u{1F514} Active Speaker Size cannot be greater than",
        this.MAX_SIZE
      );
      return;
    }
    this.__size = size;
  }}
  /**
   * Handle all the events emitted by the bot.
   */
  __init5() {this.__handleBotEvents = () => {
    if (this.__bot.listenerCount("active-speakers-change") === 0) {
      this.__bot.on("active-speakers-change", this.__handleActiveSpeakerChange);
    }
  }}
  __init6() {this.__handleClosingAllEvents = () => {
    this.on("close", () => {
      this.__active = false;
      this.__bot.off(
        "active-speakers-change",
        this.__handleActiveSpeakerChange
      );
    });
  }}
  __init7() {this.__handleActiveSpeakerChange = (data) => {
    try {
      const { peerIds } = data;
      this.__activePeerIds = peerIds;
      logger.debug("\u{1F514} Active Speakers Change", this.__activePeerIds);
      const slicedPeerData = peerIds.slice(0, this.__size);
      this.__room.emit("active-speakers-change", {
        peerIds: _nullishCoalesce(slicedPeerData, () => ( [])),
        dominantSpeaker: _nullishCoalesce(_optionalChain([peerIds, 'optionalAccess', _2 => _2[0]]), () => ( ""))
      });
    } catch (error) {
      logger.error("Error: Handling New Active Speakers Notification", error);
      logger.error(error);
    }
  }}
  constructor(data) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);_class.prototype.__init6.call(this);_class.prototype.__init7.call(this);;
    this.__bot = data.bot;
    this.__size = _nullishCoalesce(_optionalChain([data, 'optionalAccess', _3 => _3.size]), () => ( 8));
    this.__active = true;
    this.__handleBotEvents();
    this.__handleClosingAllEvents();
  }
}, _class);
var ActiveSpeakers_default = ActiveSpeakers;



exports.ActiveSpeakers_default = ActiveSpeakers_default;
