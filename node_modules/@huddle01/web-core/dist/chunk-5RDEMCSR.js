import {
  require_rtp_parameters_pb
} from "./chunk-6SZRNOKT.js";
import {
  __toESM
} from "./chunk-EK4TMKVS.js";

// src/helpers/ProtooParsing.ts
var import_rtp_parameters_pb = __toESM(require_rtp_parameters_pb(), 1);
var parseRouterRtpCapabilities = (rtpCapabilities) => {
  const parsedRouterRtpCapabilites = rtpCapabilities;
  if (parsedRouterRtpCapabilites.codecs)
    for (const codec of parsedRouterRtpCapabilites.codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
        }
      }
    }
  return parsedRouterRtpCapabilites;
};
var parseRtpParameters = (rtpParameters) => {
  const parsedRtpParameters = rtpParameters;
  for (const codec of parsedRtpParameters.codecs) {
    if (codec.parameters) {
      const keys = Object.keys(codec.parameters);
      for (const key of keys) {
        if (key === "apt") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "level-asymmetry-allowed") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "packetization-mode") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "x-google-start-bitrate") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "profile-id") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
      }
    }
  }
  if (parsedRtpParameters.encodings) {
    for (const encoding of parsedRtpParameters.encodings) {
      encoding.dtx = false;
      encoding.ssrc = Number(encoding.ssrc);
      if (Number.isNaN(encoding.ssrc)) {
        encoding.ssrc = void 0;
      }
      if (encoding.rtx?.ssrc !== void 0) {
        if (Number(encoding.rtx.ssrc) === 0) {
          encoding.rtx = void 0;
        } else {
          encoding.rtx.ssrc = Number(encoding.rtx.ssrc);
        }
      } else {
        encoding.rtx = void 0;
      }
    }
  }
  const headerExtensions = parsedRtpParameters.headerExtensions;
  if (headerExtensions) {
    headerExtensions.map((headerExtension) => {
      headerExtension.encrypt = false;
      headerExtension.parameters = {};
    });
  }
  return parsedRtpParameters;
};
var parseToProtoRtpParameters = (rtpParameters) => {
  const protoEncodings = [];
  const codecs = rtpParameters.codecs;
  for (const codec of codecs) {
    if (codec.parameters) {
      const keys = Object.keys(codec.parameters);
      for (const key of keys) {
        if (key === "apt") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "level-asymmetry-allowed") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "packetization-mode") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "x-google-start-bitrate") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "profile-id") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
      }
    }
  }
  const encodings = rtpParameters.encodings;
  if (encodings) {
    for (const encoding of encodings) {
      if (Number.isNaN(encoding.ssrc)) {
        encoding.ssrc = void 0;
      }
      const protoEncoding = new import_rtp_parameters_pb.ProtoEncodings({
        ssrc: encoding.ssrc ? BigInt(encoding.ssrc) : void 0,
        rid: encoding.rid,
        codecPayloadType: encoding.codecPayloadType,
        rtx: {
          ssrc: encoding.rtx?.ssrc ? BigInt(encoding.rtx.ssrc) : void 0
        },
        dtx: encoding.dtx,
        scalabilityMode: encoding.scalabilityMode,
        scaleResolutionDownBy: encoding.scaleResolutionDownBy,
        maxBitrate: encoding.maxBitrate
      });
      protoEncodings.push(protoEncoding);
    }
  }
  return rtpParameters;
};

export {
  parseRouterRtpCapabilities,
  parseRtpParameters,
  parseToProtoRtpParameters
};
