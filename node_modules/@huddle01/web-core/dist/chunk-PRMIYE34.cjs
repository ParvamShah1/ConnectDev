"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunk32ZCNEGZcjs = require('./chunk-32ZCNEGZ.cjs');


var _chunkVLUFOOD3cjs = require('./chunk-VLUFOOD3.cjs');



var _chunkCRVOHRUMcjs = require('./chunk-CRVOHRUM.cjs');



var _chunkO5HDCTOEcjs = require('./chunk-O5HDCTOE.cjs');


var _chunk4FMC7UH2cjs = require('./chunk-4FMC7UH2.cjs');

// src/HuddleClient.ts
var import_socket = _chunk4FMC7UH2cjs.__toESM.call(void 0, _chunkCRVOHRUMcjs.require_socket_types.call(void 0, ), 1);
var logger = _chunkO5HDCTOEcjs.mainLogger.createSubLogger("HuddleClient");
var HuddleClient = (_class = class {
  /**
   * Connection Manager Instance, Hanlder socket connection and stores information about the connection
   */
  
  /**
   * Room Instance, Handles the room and its connection
   */
  
  /**
   * Local Peer Instance, Handles the local peer and its connection
   */
  
  /**
   * Project Id of the Huddle01 Project
   */
  
  /**
   * Returns the underlying socket connection
   * @throws { Error } If the socket connection is not initialized
   */
  get socket() {
    if (!this.__socket) {
      throw new Error(
        "Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first"
      );
    }
    return this.__socket;
  }
  /**
   * Returns the room instance, throws an error if the room is not created
   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room
   */
  get room() {
    return this.__room;
  }
  get localPeer() {
    return this.__localPeer;
  }
  /**
   * Room Id of the current room
   */
  get roomId() {
    return this.room.roomId;
  }
  /**
   * Set a new region for the Huddle01 Media Servers
   */
  __init() {this.setRegion = (region) => {
    logger.info("Setting a new region, ", region);
    this.socket.setRegion(region);
  }}
  constructor(data) {;_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);
    if (_optionalChain([data, 'access', _ => _.options, 'optionalAccess', _2 => _2.logging])) {
      _chunkO5HDCTOEcjs.setLogLevel.call(void 0, "trace");
    }
    logger.info("\u2705 Initializing HuddleClient");
    this.projectId = data.projectId;
    this.__socket = _chunkCRVOHRUMcjs.Socket_default.create();
    this.__room = _chunkVLUFOOD3cjs.Room_default.create({
      autoConsume: _optionalChain([data, 'access', _3 => _3.options, 'optionalAccess', _4 => _4.autoConsume])
    });
    this.__localPeer = _chunk32ZCNEGZcjs.LocalPeer_default.create();
    const isLocalDev = this.projectId === "development";
    if (isLocalDev) {
      logger.info("\u{1F534} Local Development Mode");
      this.socket.enableLocalDev();
    }
    this.__socket.on("closed", (code) => {
      logger.info(
        "\u{1F50C} Socket Connection closed, closing the room and LocalPeer"
      );
      if (code === import_socket.ESocketCloseCode.ROOM_CLOSED) {
        this.room.close("CLOSED");
      } else if (code === import_socket.ESocketCloseCode.ROOM_ENTRY_DENIED) {
        this.room.close("DENIED");
      } else if (code === import_socket.ESocketCloseCode.CONNECTION_EXPIRED) {
        logger.info("\u{1F50C} Socket Connection closed due to connection expired");
        this.room.close();
      } else if (code === import_socket.ESocketCloseCode.KICKED) {
        this.room.close("KICKED");
      } else {
        this.room.close();
      }
      this.localPeer.close();
    });
    if (_optionalChain([data, 'access', _5 => _5.options, 'optionalAccess', _6 => _6.activeSpeakers, 'optionalAccess', _7 => _7.size])) {
      this.__room.once("room-joined", () => {
        this.localPeer.activateActiveSpeakersNotification(
          _optionalChain([data, 'access', _8 => _8.options, 'optionalAccess', _9 => _9.activeSpeakers, 'optionalAccess', _10 => _10.size])
        ).catch((error) => {
          logger.error(
            "\u{1F534} Error while activating active speakers notification",
            error
          );
        });
      });
    }
  }
  /**
   * Default method to connect to the Huddle01 Media Room.
   *
   * This method connects to socket, creates a room, and then connects to the room;
   */
  __init2() {this.joinRoom = async (data) => {
    logger.info("\u{1F514} Joining the room with roomId,", data.roomId);
    if (this.socket.connectionState === "connecting") {
      logger.warn(
        "\u{1F514} Socket is already connecting, waiting for the connection to be established"
      );
      return this.room;
    }
    if (this.room.state === "connecting") {
      logger.warn("\u{1F514} Room join already in progress");
      return this.room;
    }
    if (this.localPeer.joined) {
      logger.warn("\u{1F514} Already joined the room");
      return this.room;
    }
    try {
      await this.socket.connect({ token: data.token });
      this.room.roomId = data.roomId;
      const room = this.room.connect();
      return room;
    } catch (error) {
      logger.error("\u{1F534} Error While Joining the Room");
      logger.error(error);
      throw error;
    }
  }}
  /**
   * Leave the room and disconnect from the socket
   */
  __init3() {this.leaveRoom = () => {
    logger.info("Leaving the room");
    this.socket.close(import_socket.ESocketCloseCode.NORMAL_CLOSURE);
  }}
  /**
   * Close the room and disconnect from the socket
   */
  __init4() {this.closeRoom = () => {
    logger.info("Closing the room");
    this.socket.publish("closeRoom", void 0);
  }}
}, _class);
var HuddleClient_default = HuddleClient;



exports.HuddleClient_default = HuddleClient_default;
