"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkCRVOHRUMcjs = require('./chunk-CRVOHRUM.cjs');


var _chunkUL4JRY5Xcjs = require('./chunk-UL4JRY5X.cjs');


var _chunkAA6KQKWQcjs = require('./chunk-AA6KQKWQ.cjs');


var _chunkO5HDCTOEcjs = require('./chunk-O5HDCTOE.cjs');

// src/Room.ts
var logger = _chunkO5HDCTOEcjs.mainLogger.createSubLogger("Room.ts");
var Room = (_class = class _Room extends _chunkAA6KQKWQcjs.EnhancedEventEmitter {
  /**
   * Room Instance, Singleton class
   */
  static __initStatic() {this.__instance = null}
  /**
   * Socket Instance, Singleton class
   */
  __init() {this.__socket = _chunkCRVOHRUMcjs.Socket_default.getInstance()}
  /**
   * Returns the instance of the socket connection
   */
  get socket() {
    return this.__socket;
  }
  /**
   * Room Id of the current room
   */
  __init2() {this.__roomId = null}
  /**
   * session id
   */
  __init3() {this.__sessionId = null}
  /**
   * Lobby PeerIds
   */
  __init4() {this.__lobbyPeers = /* @__PURE__ */ new Map()}
  /**
   * Removed Lobby PeerId from the lobby
   * @param peerId - PeerId of the peer who joined the room
   */
  __init5() {this.removeLobbyPeer = (peerId) => {
    this.__lobbyPeers.delete(peerId);
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  }}
  /**
   * Room Config Object
   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
   * - `allowSendData`: Allow non-admin Peers in the Room to send data message
   * - `roomLocked`: If the room is locked
   */
  __init6() {this.__config = {
    roomLocked: false,
    allowProduce: true,
    allowProduceSources: {
      cam: true,
      mic: true,
      screen: true
    },
    allowConsume: true,
    allowSendData: true
  }}
  /**
   * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
   *
   * @default true
   *
   * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
   * - if set to false, the user will have to manually consume the media streams of the remote peers
   * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  __init7() {this.autoConsume = true}
  /**
   * Handler for the ActiveSpeaker
   */
  __init8() {this.__activeSpeakers = null}
  /**
   * Get the active speakers instance
   */
  get activeSpeakers() {
    return this.__activeSpeakers;
  }
  set activeSpeakers(activeSpeakers) {
    if (this.__activeSpeakers) {
      logger.warn(
        "Active Speakers is already set, Ignoring the new active speakers, end this room and create a new room"
      );
    }
    this.__activeSpeakers = activeSpeakers;
  }
  /**
   * State of the Room
   */
  __init9() {this.__state = "idle"}
  /**
   * Room Stats
   */
  __init10() {this.__stats = {
    startTime: 0
  }}
  /**
   * Set the state of the room
   */
  set state(newState) {
    if (this.state !== newState) {
      this.__state = newState;
    }
  }
  /**
   * State of the room
   */
  get state() {
    return this.__state;
  }
  /**
   * Get the lobby peers in the form of map
   * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
   * @example
   * ```ts
   * const lobbyPeers = room.lobbyPeersMap;
   *
   * for (const [peerId, metadata] of lobbyPeers) {}
   *
   * ```
   */
  get lobbyPeersMap() {
    return this.__lobbyPeers;
  }
  /**
   * Get lobby peers in the form of array
   */
  get lobbyPeerIds() {
    return Array.from(this.__lobbyPeers.keys());
  }
  /**
   * Get lobby peers in the form of array
   * @returns - Array of Lobby PeerIds
   */
  get lobbyPeers() {
    return this.__lobbyPeers;
  }
  /**
   * Set lobby peers in the form of map
   * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
   */
  set lobbyPeersMap(peers) {
    this.__lobbyPeers = peers;
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  }
  /**
   * Get Room Stats
   */
  get stats() {
    return this.__stats;
  }
  /**
   * Set Room Stats
   */
  set stats(stats) {
    this.__stats = stats;
  }
  /**
   * Get
   * @returns
   */
  __init11() {this.getLobbyPeerMetadata = (peerId) => {
    const lobbyPeer = this.lobbyPeers.get(peerId);
    let metadata = {};
    if (_optionalChain([lobbyPeer, 'optionalAccess', _2 => _2.metadata])) {
      metadata = JSON.parse(lobbyPeer.metadata);
    }
    return {
      peerId,
      metadata
    };
  }}
  /**
   * Set lobby peers in the form of array
   */
  set newlobbyPeers(peers) {
    for (const peer of peers) {
      this.__lobbyPeers.set(peer.peerId, peer);
    }
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  }
  /**
   * Room Config Object
   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
   * - `allowSendData`: Allow non-admin Peers in the Room to send data message
   * - `roomLocked`: If the room is locked
   */
  get config() {
    return this.__config;
  }
  set config(config) {
    this.__config = config;
  }
  /**
   * Remote Peers Map, Stores all the remote peers
   */
  __init12() {this.remotePeers = /* @__PURE__ */ new Map()}
  /**
   * Metadata of the room.
   */
  __init13() {this.__metadata = "{}"}
  /**
   * Setter function for the metadata of the room
   * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
   * `To notify everyone in the room about the metadata change, use the updateMetadata function`
   */
  set metadata(metadata) {
    this.__metadata = metadata;
    const parse = JSON.parse(metadata);
    this.emit("metadata-updated", parse);
  }
  /**
   * Get the metadata of the room
   */
  __init14() {this.getMetadata = () => {
    const data = JSON.parse(this.__metadata || "{}");
    return data;
  }}
  /**
   * Update Metadata of the room
   */
  __init15() {this.updateMetadata = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, {}).validate(
    (data) => {
      try {
        if (this.state === "closed" || this.state === "failed" || this.state === "left") {
          logger.error(
            "\u274C Cannot Update Metadata, You have not joined the room yet"
          );
          return;
        }
        const metadata = JSON.stringify(data);
        this.metadata = metadata;
        this.socket.publish("updateRoomMetadata", {
          metadata
        });
      } catch (error) {
        logger.error("\u274C Error Updating Metadata");
        logger.error(error);
      }
    }
  )}
  /**
   * Create a new Room Instance if not created, else return the existing Room Instance
   *
   * @returns - Room Instance
   */
  static create(data) {
    if (_Room.__instance) {
      return _Room.__instance;
    }
    logger.debug({ data });
    _Room.__instance = new _Room(data);
    return _Room.__instance;
  }
  /**
   * Get the Room Instance if its not initialized it will throw an error
   * @returns - Room Instance
   * @throws { Error } If the Room Instance is not initialized
   */
  static __initStatic2() {this.getInstance = () => {
    if (!_Room.__instance) {
      throw new Error("\u274C Room Instance Not Initialized");
    }
    return _Room.__instance;
  }}
  /**
   * RoomId of the currently joined room.
   */
  get roomId() {
    return this.__roomId;
  }
  /**
   *
   */
  get sessionId() {
    return this.__sessionId;
  }
  set roomId(roomId) {
    if (this.__roomId) {
      logger.warn(
        "RoomId is already set, Ignoring the new roomId, end this room and create a new room"
      );
      return;
    }
    this.__roomId = roomId;
  }
  set sessionId(sessionId) {
    if (this.__sessionId) {
      logger.warn(
        "sessionId is already set, Ignoring the new sessionId, end this room and create a new room"
      );
      return;
    }
    this.__sessionId = sessionId;
  }
  /**
   * Returns the PeerIds of the remote peers
   */
  get peerIds() {
    return Array.from(this.remotePeers.keys());
  }
  /**
   * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
   * @param data: TNewRoomControls
   */
  __init16() {this.updateRoomControls = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, {
    admin: true
  }).validate((data) => {
    logger.info("\u{1F514} Updating Room Controls", data);
    this.config[data.type] = data.value;
    this.emit("room-controls-updated");
    if (data.type === "allowProduceSources") {
      this.socket.publish("updateRoomControls", {
        control: {
          case: "produceSourcesControl",
          value: data
        }
      });
    } else {
      this.socket.publish("updateRoomControls", {
        control: {
          case: "roomControl",
          value: data
        }
      });
    }
  })}
  /**
   * Close a particular stream of remote peers
   *  @param data: { label: string; peerIds?: string[] }
   *  @param label: Label of the stream
   *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
   */
  __init17() {this.closeStreamOfLabel = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, {}).validate(
    (data) => {
      logger.info("\u{1F514} Closing Stream of Label", data);
      this.socket.publish("closeStreamOfLabel", data);
    }
  )}
  /**
   * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
   *
   * `NOTE: This will target all the audio stream in the room with the label "audio"`
   */
  __init18() {this.muteEveryone = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, { admin: true }).validate(() => {
    logger.info("\u{1F514} Muting Everyone");
    this.socket.publish("closeStreamOfLabel", {
      label: "audio"
    });
  })}
  /**
   * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
   *
   * @param peerId - PeerId of the remote peer
   * @returns - RemotePeer Instance
   * @return - null if the peer is not present in the room
   */
  __init19() {this.remotePeerExists = (peerId) => {
    const peer = this.remotePeers.get(peerId);
    if (!peer) {
      return null;
    }
    return peer;
  }}
  /**
   * Returns the Remote Peer if present in room.
   * @param peerId - PeerId of the remote peer
   * @returns - RemotePeer Instance
   * @throws { Error } If the Remote Peer is not found
   */
  getRemotePeerById(peerId) {
    const peer = this.remotePeers.get(peerId);
    if (!peer) {
      throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);
    }
    return peer;
  }
  constructor(data) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);_class.prototype.__init6.call(this);_class.prototype.__init7.call(this);_class.prototype.__init8.call(this);_class.prototype.__init9.call(this);_class.prototype.__init10.call(this);_class.prototype.__init11.call(this);_class.prototype.__init12.call(this);_class.prototype.__init13.call(this);_class.prototype.__init14.call(this);_class.prototype.__init15.call(this);_class.prototype.__init16.call(this);_class.prototype.__init17.call(this);_class.prototype.__init18.call(this);_class.prototype.__init19.call(this);_class.prototype.__init20.call(this);_class.prototype.__init21.call(this);_class.prototype.__init22.call(this);_class.prototype.__init23.call(this);_class.prototype.__init24.call(this);;
    if (_optionalChain([data, 'optionalAccess', _3 => _3.autoConsume]) !== void 0) {
      this.autoConsume = data.autoConsume;
    }
  }
  /**
   * Connects to the room and returns the instance of the room
   * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
   */
  __init20() {this.connect = () => {
    if (_Room.__instance === null) {
      throw new Error("Room Instance Not Initialized");
    }
    if (!this.socket.connected) {
      throw new Error("Socket is Not Connected");
    }
    if (this.socket.connecting) {
      throw new Error("Socket is Connecting, Wait for it to be connected");
    }
    if (!this.roomId) {
      throw new Error("Room Id is required to connect to the room");
    }
    logger.info("\u{1F514} Connecting to the room");
    this.socket.publish("connectRoom", { roomId: this.roomId });
    this.__state = "connecting";
    this.emit("room-connecting");
    return _Room.__instance;
  }}
  /**
   * Admit a Peer to the room who is in the lobby
   */
  __init21() {this.admitPeer = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, { admin: true }).validate(
    (peerId) => {
      try {
        this.removeLobbyPeer(peerId);
        this.socket.publish("acceptLobbyPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error admitting peer", error);
      }
    }
  )}
  /**
   * Denies the peer from joining the room, who is in the lobby
   */
  __init22() {this.denyPeer = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, { admin: true }).validate(
    (peerId) => {
      try {
        this.removeLobbyPeer(peerId);
        this.socket.publish("denyLobbyPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error denying peer", error);
      }
    }
  )}
  /**
   * kick peer from room with respective peerId
   */
  __init23() {this.kickPeer = _chunkUL4JRY5Xcjs.checkPermissions.call(void 0, { admin: true }).validate(
    (peerId) => {
      try {
        this.socket.publish("kickPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error denying peer", error);
      }
    }
  )}
  /**
   * closing the room for the current user, room will keep on running for the remote users
   * @deprecated - Use `leaveRoom` from `huddleClient` instead
   */
  __init24() {this.close = (reason) => {
    try {
      logger.info("\u{1F534} Leaving the room");
      this.__roomId = null;
      this.remotePeers.clear();
      this.lobbyPeers.clear();
      this.metadata = "{}";
      this.state = "left";
      this.emit("room-closed", { reason: reason || "LEFT" });
    } catch (error) {
      logger.error("Error: Leaving the Room");
    }
  }}
}, _class.__initStatic(), _class.__initStatic2(), _class);
var Room_default = Room;



exports.Room_default = Room_default;
