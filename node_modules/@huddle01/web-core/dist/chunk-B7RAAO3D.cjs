"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkAA6KQKWQcjs = require('./chunk-AA6KQKWQ.cjs');


var _chunkO5HDCTOEcjs = require('./chunk-O5HDCTOE.cjs');

// src/Consumer.ts
var logger = _chunkO5HDCTOEcjs.mainLogger.createSubLogger("Consumer");
var Consumer = (_class = class _Consumer extends _chunkAA6KQKWQcjs.EnhancedEventEmitter {
  /**
   * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
   */
  
  /**
   * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
   */
  
  /**
   * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
   */
  
  /**
   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
   *
   * @default false
   */
  __init() {this.__consuming = false}
  /**
   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
   *
   * @default false
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get consuming() {
    return this.__consuming;
  }
  /**
   * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.
   * @remarks This is a private property and should not be accessed directly.
   *
   * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.
   */
  #mediasoupConsumer = null;
  /**
   * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
   */
  get id() {
    return _optionalChain([this, 'access', _10 => _10.#mediasoupConsumer, 'optionalAccess', _11 => _11.id]);
  }
  /**
   *
   * @param consumer Sets the mediasoupConsumer for the Consumer
   */
  setMediaSoupConsumer(consumer) {
    if (this.consuming) {
      throw new Error("Consumer is already consuming");
    }
    if (this.#mediasoupConsumer) {
      throw new Error("Consumer already has a mediasoupConsumer");
    }
    this.#mediasoupConsumer = consumer;
    this.__consuming = true;
  }
  /**
   * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get consumerId() {
    return _optionalChain([this, 'access', _12 => _12.#mediasoupConsumer, 'optionalAccess', _13 => _13.id]);
  }
  /**
   * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get track() {
    return _optionalChain([this, 'access', _14 => _14.#mediasoupConsumer, 'optionalAccess', _15 => _15.track]);
  }
  /**
   * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get kind() {
    return _optionalChain([this, 'access', _16 => _16.#mediasoupConsumer, 'optionalAccess', _17 => _17.kind]);
  }
  /**
   * If the Consumer is paused, it is only available when the Consumer is consuming a media.
   *
   * if paused the user is not consuming any media for the given producerId.
   */
  get paused() {
    return _optionalChain([this, 'access', _18 => _18.#mediasoupConsumer, 'optionalAccess', _19 => _19.paused]);
  }
  /**
   * AppData of the Consumer, it is only available when the Consumer is consuming a media.
   */
  get appData() {
    return _optionalChain([this, 'access', _20 => _20.#mediasoupConsumer, 'optionalAccess', _21 => _21.appData]);
  }
  /**
   * State of a Consumer is defined by the following:
   * - `playable` - The Consumer is ready to play the media.
   * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
   * - `paused` - The Consumer is paused and is not playing the media.
   * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
   */
  get state() {
    if (_optionalChain([this, 'optionalAccess', _22 => _22.consuming]))
      return "playable";
    if (_optionalChain([this, 'optionalAccess', _23 => _23.paused]))
      return "paused";
    return "available";
  }
  /**
   * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
   * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
   * @returns - RTCStatsReport | null
   */
  __init2() {this.getStats = async () => {
    const stats = await _optionalChain([this, 'access', _24 => _24.#mediasoupConsumer, 'optionalAccess', _25 => _25.getStats, 'call', _26 => _26()]);
    return stats;
  }}
  /**
   * Resume the consumer, if the state of the consumer is `paused`.
   */
  __init3() {this.resume = () => {
    _optionalChain([this, 'access', _27 => _27.#mediasoupConsumer, 'optionalAccess', _28 => _28.resume, 'call', _29 => _29()]);
  }}
  /**
   * Removes all the eventListeners attached to the Consumer.
   */
  __init4() {this.removeListeners = () => {
    this.removeAllListeners();
  }}
  /**
   * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
   */
  static __initStatic() {this.create = (data) => {
    try {
      const consumer = new _Consumer(data);
      return consumer;
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error creating Consumer");
    }
  }}
  __init5() {this.close = () => {
    try {
      _optionalChain([this, 'access', _30 => _30.#mediasoupConsumer, 'optionalAccess', _31 => _31.close, 'call', _32 => _32()]);
      this.__consuming = false;
      this.emit("closed");
      this.removeAllListeners();
    } catch (error) {
      logger.error("\u274C Error Closing Consumer");
      logger.error({
        consumerId: this.consumerId,
        producerId: this.producerId
      });
    }
  }}
  constructor(data) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);;
    this.producerPeerId = data.producerPeerId;
    this.producerId = data.producerId;
    this.label = data.label;
  }
}, _class.__initStatic(), _class);
var Consumer_default = Consumer;



exports.Consumer_default = Consumer_default;
