"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkMGUCXW7Mcjs = require('./chunk-MGUCXW7M.cjs');


var _chunk4FMC7UH2cjs = require('./chunk-4FMC7UH2.cjs');

// src/helpers/ProtooParsing.ts
var import_rtp_parameters_pb = _chunk4FMC7UH2cjs.__toESM.call(void 0, _chunkMGUCXW7Mcjs.require_rtp_parameters_pb.call(void 0, ), 1);
var parseRouterRtpCapabilities = (rtpCapabilities) => {
  const parsedRouterRtpCapabilites = rtpCapabilities;
  if (parsedRouterRtpCapabilites.codecs)
    for (const codec of parsedRouterRtpCapabilites.codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
        }
      }
    }
  return parsedRouterRtpCapabilites;
};
var parseRtpParameters = (rtpParameters) => {
  const parsedRtpParameters = rtpParameters;
  for (const codec of parsedRtpParameters.codecs) {
    if (codec.parameters) {
      const keys = Object.keys(codec.parameters);
      for (const key of keys) {
        if (key === "apt") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "level-asymmetry-allowed") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "packetization-mode") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "x-google-start-bitrate") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
        if (key === "profile-id") {
          codec.parameters[key] = Number(codec.parameters[key]);
        }
      }
    }
  }
  if (parsedRtpParameters.encodings) {
    for (const encoding of parsedRtpParameters.encodings) {
      encoding.dtx = false;
      encoding.ssrc = Number(encoding.ssrc);
      if (Number.isNaN(encoding.ssrc)) {
        encoding.ssrc = void 0;
      }
      if (_optionalChain([encoding, 'access', _ => _.rtx, 'optionalAccess', _2 => _2.ssrc]) !== void 0) {
        if (Number(encoding.rtx.ssrc) === 0) {
          encoding.rtx = void 0;
        } else {
          encoding.rtx.ssrc = Number(encoding.rtx.ssrc);
        }
      } else {
        encoding.rtx = void 0;
      }
    }
  }
  const headerExtensions = parsedRtpParameters.headerExtensions;
  if (headerExtensions) {
    headerExtensions.map((headerExtension) => {
      headerExtension.encrypt = false;
      headerExtension.parameters = {};
    });
  }
  return parsedRtpParameters;
};
var parseToProtoRtpParameters = (rtpParameters) => {
  const protoEncodings = [];
  const codecs = rtpParameters.codecs;
  for (const codec of codecs) {
    if (codec.parameters) {
      const keys = Object.keys(codec.parameters);
      for (const key of keys) {
        if (key === "apt") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "level-asymmetry-allowed") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "packetization-mode") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "x-google-start-bitrate") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
        if (key === "profile-id") {
          codec.parameters[key] = String(codec.parameters[key]);
        }
      }
    }
  }
  const encodings = rtpParameters.encodings;
  if (encodings) {
    for (const encoding of encodings) {
      if (Number.isNaN(encoding.ssrc)) {
        encoding.ssrc = void 0;
      }
      const protoEncoding = new import_rtp_parameters_pb.ProtoEncodings({
        ssrc: encoding.ssrc ? BigInt(encoding.ssrc) : void 0,
        rid: encoding.rid,
        codecPayloadType: encoding.codecPayloadType,
        rtx: {
          ssrc: _optionalChain([encoding, 'access', _3 => _3.rtx, 'optionalAccess', _4 => _4.ssrc]) ? BigInt(encoding.rtx.ssrc) : void 0
        },
        dtx: encoding.dtx,
        scalabilityMode: encoding.scalabilityMode,
        scaleResolutionDownBy: encoding.scaleResolutionDownBy,
        maxBitrate: encoding.maxBitrate
      });
      protoEncodings.push(protoEncoding);
    }
  }
  return rtpParameters;
};





exports.parseRouterRtpCapabilities = parseRouterRtpCapabilities; exports.parseRtpParameters = parseRtpParameters; exports.parseToProtoRtpParameters = parseToProtoRtpParameters;
